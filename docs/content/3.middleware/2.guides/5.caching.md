# Caching

Caching is another powerful technique allowing to boost performance of your VSF application and it's reliability. In the following guide, we will cover subject of caching responses from GET endpoints that are possible to cache.

## Implementation

A caching strategy in middleware has to be implemented per integration. We share a very basic extension showing how to approach it for each of our eCommerce integrations (SAP commerce, commercetools, bigcommerce, Adobe commerce). Copy code of an extension for you eCommerce and assign it to constant inside `middleware.config.js`:

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;
        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getCategory") {
          console.log(
            "[CACHING] It's a getCategory request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=31557600");
        } else if (apiMethod === "getFacet") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=315576");
          } else {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements not fulfilled!"
            );
          }
        }
        return response;
      },
    };
  },
};
```

Then add it to the `extensions` array:

```js{20}[middleware.config.js]
const middlewareConfig = {
  integrations: {
    ct: {
      location: "@vsf-enterprise/commercetools-api/server",
      extensions: (extensions) => [...extensions, cachingExtension]
      configuration: {
        // ...
      },
    },
  },
};
```

Since now, if an endpoint is cookie independent then the extension will set Cache-Control response header that should be respected by your CDN and user's browser.

:::warning
Shared caching extension assume you are using the newest version of the middleware's integration and neither extend nor overwrite mentioned endpoints. If you do then you have responsibility to customize extension and custom endpoint's code to be safe to cache or exclude it from caching.
:::

## Understanding the caching extension

In this section, we are going through the code of aforementioned caching extension and explain it's parts.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        // ...
        return response
      }
    }
  }
};
```

Firstly, we assign a name to the extension and register `afterCall` hook which is called after execution of endpoint's code but before sending a response to the client. This is the perfect place to make essential checks and set Cache-Control response header. Inside, we have to return `response` .

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        return response
      }
    }
  }
};
```

Secondly, we add a check for HTTP Method that has been used. As we want to cache only GET request, we log and finish function's call for other values.
:::tip
We've used console.log and decided to make code of extension super simple and repetitive to make it easy to grasp and be a good starting points for different approaches. Don't hesitate to modify and refactor it to match your vision, and your business' edge cases.
:::

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        return response
      }
    }
  }
};
```

Then we make sure, the response doesn't contain Set-Cookie header. If these things are already check then we can move to checks per endpoint.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        }

        return response
      }
    }
  }
};
```

We create 2 constants containg name of the currently called API endpoint and it's params. There are 3 cases we should consider. In the simplest one, which is for xample `getReview` endpoint - there weren't any cookie related operations so we could easily set Cache-Control headers if `apiMethod` equals `getReview`.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

A case of `getStores` endpoint is a bit more complicated. It used to read `locale` from the cookie. To maintain backward compatibility, we left this mechanism but it won't be used if you pass `locale` via query params. Knowing that, we can only cache responses including `locale` query param in the request's URL.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

A case of `getProduct` endpoint is similiar but a tiny bit more complicated. It used to read a few cookies that are always available and a two that are **optional**. Knowing that, we have to check optional fields like that `"channel" in params` and send theirs value as `{ channel: null }` in SDK method. Sending value equal `null` for optional fields prevents it from calling fallback mechanism using cookies.

THATS IT 


Usage:

```javascript
const sapcc = context.getApiClient("sapcc");
```

The `getApiClient` method takes a single argument, which is the key of the api client you wish to retrieve. This is the key you would define in the `middleware.config.js` file for the integration you wish to retrieve. The key is essentially an identifier for the integration.

Here's a basic example of what this might look like:

```javascript
export const integrations = {
  sapcc: {
    location: "@vsf-enterprise/sapcc-api/server",
    configuration: {
      // ...
    },
    extensions: (extensions) => [
      ...extensions,
      {
        name: "sapcc-contentful-extension",
        extendApiMethods: {
          getPDP: async (context, params: { id: string }) => {
            const sapcc = context.getApiClient("sapcc");
            const contentful = context.getApiClient("contentful");

            const [product, content] = Promise.all(
              sapcc.api.getProduct({ id: params.id }),
              contentful.api.getEntries({
                content_type: "product",
                "fields.sku": params.id,
              })
            );

            return {
              product,
              content,
            };
          },
        },
      },
    ],
  },
  contentful: {
    location: "@vsf-enterprise/contentful-api/server",
    configuration: {
      // ...
    },
  },
};
```

1. Extend the integration with new endpoint: Create a new endpoint that will act as the main entry point for the grouped requests.

2. Group Server Requests: Within this endpoint, utilize the `getApiClient` method to retrieve and interact with the required integrations.

3. Aggregate Data: Once data from all required integrations is retrieved, aggregate and format it as needed.

4. Return Unified Response: Send a consolidated response back to the frontend.:

### Using orchestration methods in the frontend

To call the orchestration endpoint, you need to send a POST request to the endpoint URL. In our example it would be `POST http://localhost:8080/sapcc/getPDP`. The request body should contain the parameters required by the endpoint.

When it comes to extending the Vue Storefront integrations like `sapcc` or `contentful`, you can use the SDK extension mechanism as described in the [Extending a Module](/sdk/advanced/extending-module) guide.

To extend the `sapcc-sdk` with our new `getPDP` method, we would need to create a new extension:

```javascript [sapccExtension.ts]
import { client } from "@vsf-enterprise/sapcc-sdk";

export const sapccExtension = {
  extend: {
    getPDP: async (params: { id: string }) => {
      const { product, content } = await client.post("/getPDP", params);

      return {
        product,
        content,
      };
    },
  },
};
```

Of course, you can use another fetching mechanism, like `axios` or `fetch`, but the `client` is already configured with the correct URL and headers.

## Examples

Let's take a look at some examples of how you can use orchestration.

### Example 1: Fetching Custom Product Properties from Legacy Systems

This use case involves calling the commerce backend to fetch specific product data. Additionally, a separate call is made to a legacy custom system of the customer, to retrieve a custom product property (e.g., stock of the product). This data is used, for example, to display stock information on the product page.

Example implementation might look like this:

```typescript [middleware.config.ts]
export const integrations = {
  sapcc: {
    // ...
    extensions: (extensions) => [
      ...extensions,
      {
        name: "orchestration-extension",
        extendApiMethods: {
          enrichedSearch: async (context, params: { productId: string }) => {
            const sapcc = context.getApiClient("sapcc");
            const legacyCustomSystem = context.getApiClient("legacyCustomSystem");

            const prouctStock = await legacyCustomSystem.api.getProductStock({
              productId: params.productId,
            });

            const product = await sapcc.api.getProduct({
              { id: params.productId },
            });

            return {
              ...product,
              stock: productStock,
            };
          },
        },
      },
    ],
  },
  legacyCustomSystem: {
    // ...
  },
};
```

### Example 2: Product Slider Orchestration with Commerce Backend Data

In this scenario, the CMS returns a product slider component that lacks sufficient product data (or contains only product IDs). The orchestration layer enhances the product slider by adding product data from the commerce backend, ensuring a comprehensive and informative display.

```typescript [middleware.config.ts]
export const integrations = {
  sapcc: {
    // ...
    extensions: (extensions) => [
      ...extensions,
      {
        name: "orchestration-extension",
        extendApiMethods: {
          getProductSlider: async (
            context: IntegrationContext,
            props: { entryId: string }
          ) => {
            const contentful: ApiClient<ContentfulEndpoints> =
              context.getApiClient("contentful");
            const sapcc: ApiClient<SapccEndpoints> =
              context.getApiClient("sapcc");

            const content = await contentful.api.getEntry(props.entryId);
            const productItems = await Promise.all(
              content.fields.items.map(async (item) => {
                const product = await sapcc.api.getProduct({
                  id: item.fields.productId,
                });

                return {
                  ...item,
                  fields: {
                    ...item.fields,
                    ...product,
                  },
                };
              })
            );

            return {
              ...content,
              fields: {
                ...content.fields,
                items: productItems,
              },
            };
          },
        },
      },
    ],
  },
  contentful: {
    // ...
  },
};
```
