# Caching

Caching is another powerful technique allowing to boost performance of your VSF middleware application and it's reliability. In the following guide, we will cover subject of caching responses from GET endpoints that are possible to cache.

## What are requirements to cache endpoint's response?

If you created or overwritten an endpoint and would like to cache the response then an endpoint has to be:

- GET HTTP method,
- cookie independent - it cannot build response based on the values of cookie,
- variables has to be send as URL query params.

If aforementioned requirements are fullfiled then you can safely cache a response.

### What if I cache a response not fullfiling requirements?

It is possible that either CDN won't be able to cache or it will cache a response dedicated for particular user and other users will also get this response.

You might wonder, how can we asure requirements are fullfiled? An answer is caching extension!

## Understanding the caching extension

As there are many edge cases that different clients could require, we decided to provide freely available middleware caching extensions per eCommerce integration that can be used as a starting point in your application. Thanks to that, you won't be limited and you will be able to develop custom rules for exact endpoints or set of endpoints the way that suits your business needs bestly.

In this section, we will go build sample caching extension from scratch and explain the thinking process behind it.

Firstly, we assign a name to the extension and register `afterCall` hook which is called after execution of endpoint's code but before sending a response to the client. This is the perfect place to make essential checks and set **Cache-Control** response header. Inside, we have to return an original `response` which is required by the hook to maintaing the contract but not really related to the caching part.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        // ...
        return response
      }
    }
  }
};
```

We have a basic structure then we want to filter out cases that cannot be cached. For that, we add a check for HTTP Method. As we want to cache only GET request.
:::tip
We've used console.log and decided to make code of extension super simple and repetitive to make it easy to grasp and be a good starting points for different approaches. Don't hesitate to modify and refactor it to match your vision, and your business' edge cases. E.g. here remove log or replace it with `debug` function from some `Logger` library.
:::

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        return response
      }
    }
  }
};
```

There is another case we need to filter out - the response doesn't contain Set-Cookie header.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        return response
      }
    }
  }
};
```

If these things are already checked then we can move to checks per endpoint. We create 2 constants containg name of the currently called API endpoint and it's params. There are 3 cases we should consider. In the simplest one, which is for example `getReview` endpoint (we are basing on commercetools integration in this guide) - there weren't any cookie related operations so we could easily set **Cache-Control** headers if `apiMethod` equals `getReview`.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        }

        return response
      }
    }
  }
};
```

Way of calling this endpoint via SDK doesn't need any extra steps to be able to cache a response.

```ts
import { sdk } from '~/sdk.config.ts';

const { reviews } = await sdk.commerce.getProductReviews({
  productId: '891c95f8-7bf4-4945-9ab5-00906a5f76ba', // example id
  limit: 20 // example limit
});
```

A case of `getStores` endpoint is a bit more complicated. It used to read `locale` from the cookie (which breaks one of [requirements](#what-are-requirements-to-cache-endpoints-response)). To maintain backward compatibility, we left this mechanism but it won't be used if you pass `locale` via query params. Knowing that, we can only cache responses including `locale` query param in the request's URL for this particular endpoint.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          // Checking if obligatory param - `locale` has been provided
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

To pass `locale` via query params through SDK, call the method like that:

```ts
import { sdk } from '~/sdk.config.ts';

const result = await sdk.commerce.getStores({
  locale: "en"
});
```

A case of `getProduct` endpoint is similiar but a tiny bit more complicated. It used to read a few cookies that are always available and a two that are **optional**. Knowing that, we have to check optional fields the following way: `"channel" in params` and send theirs value as `{ channel: null }` in SDK method. Sending value equal `null` for optional fields prevents it from calling fallback mechanism using cookies, as the payload will be stringified and `null` value won't be lost in JSON standard.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            // Obligatory fields
            params.country &&
            params.currency &&
            params.locale &&
            // Optional fields
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

To pass required values through SDK (optional and obligatory ones), call the method like that:

```ts
import { sdk } from '~/sdk.config.ts';

const { products } = await sdk.commerce.getProduct({
  country: "PL",
  currency: "USD",
  locale: "en",
  customerGroupId: null,
  channel: null,
});
```

## Why do I need to pass null values?

Object passed to the SDK method will be stringified and set as `body` query param in request URL. Null value will persist in JSON standard. `undefined` would be lost and cause usage of cookies as a fallback.

## Can I set multiple response headers?

For example **Cache-Control** & **CDN-Cache-Control**? Yes, it's absolutely fine.

## How do we know which SDK method calls which endpoint?

Each SDK method has detailed description and examples of usage. You can check it either in tooltip after hovering on method for a few seconds in your IDE or in API Reference of SDK package in our documentation. There you can find information what is the target URL of certain SDK method.

## Full implementation

A caching strategy in middleware has to be implemented per integration. Below, we share a very basic extension showing how to approach it for each of our eCommerce integrations (SAP commerce, commercetools, bigcommerce, Adobe commerce). Copy code of an extension for you eCommerce and assign it to constant inside `middleware.config.js`:

:::code-group
```js[commercetools]
// middleware.config.js
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;
        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getCategory") {
          console.log(
            "[CACHING] It's a getCategory request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=31557600");
        } else if (apiMethod === "getFacet") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=315576");
          } else {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements not fulfilled!"
            );
          }
        }
        return response;
      },
    };
  },
};
```

```js[bigcommerce]
// middleware.config.js
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;
        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getCategory") {
          console.log(
            "[CACHING] It's a getCategory request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=31557600");
        } else if (apiMethod === "getFacet") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=315576");
          } else {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements not fulfilled!"
            );
          }
        }
        return response;
      },
    };
  },
};
```

```js[SAP Commerce]
// middleware.config.js
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;
        // Here we reverted conditions as each aforementioned endpoint requires exactly these 2 values
        if (params.lang && params.currency) {
          if (apiMethod === "getCatalogVersion") {
            console.log(
              "[CACHING] It's a getCatalogVersion request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getCategory") {
            console.log(
              "[CACHING] It's a getCategory request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getCountries") {
            console.log(
              "[CACHING] It's a getCountries request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getCountryRegions") {
            console.log(
              "[CACHING] It's a getCountryRegions request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getProduct") {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getProductReferences") {
            console.log(
              "[CACHING] It's a getProductReferences request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getProductReviews") {
            console.log(
              "[CACHING] It's a getProductReviews request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getProductSearchPageData") {
            console.log(
              "[CACHING] It's a getProductSearchPageData request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getSuggestions") {
            console.log(
              "[CACHING] It's a getSuggestions request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "getTitles") {
            console.log(
              "[CACHING] It's a getTitles request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else if (apiMethod === "searchProduct") {
            console.log(
              "[CACHING] It's a searchProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          }
        } else {
          console.log(
            "[CACHING] 'lang' and 'currency' has to be provided as params to cache, skipping cache"
          );
        }
        return response;
      },
    };
  },
};
```
:::

:::tip
Feel free to remove `console.log` or replace it with dedicated logger if you need.
:::

Then add it to the `extensions` array:

:::code-group
```js[commercetools]
// middleware.config.js
const middlewareConfig = {
  integrations: {
    ct: {
      location: "@vsf-enterprise/commercetools-api/server",
      extensions: (extensions) => [...extensions, cachingExtension]
      configuration: {
        // ...
      },
    },
  },
};
```

```js[bigcommerce]
// middleware.config.js
const middlewareConfig = {
  integrations: {
    bigcommerce: {
      location: "@vsf-enterprise/bigcommerce-api/server",
      extensions: (extensions) => [...extensions, cachingExtension]
      configuration: {
        // ...
      },
    },
  },
};
```

```js[commercetools]
// middleware.config.js
const middlewareConfig = {
  integrations: {
    sapcc: {
      location: "@vsf-enterprise/sapcc-api/server",
      extensions: (extensions) => [...extensions, cachingExtension]
      configuration: {
        // ...
      },
    },
  },
};
```
:::

Since now, if an endpoint is cookie independent then the extension will set **Cache-Control** response header that should be respected by your CDN and user's browser.

:::warning
Shared caching extension assume you are using the newest version of the middleware's integration and neither extend nor overwrite mentioned endpoints. If you do then you have to exclude it from caching or you have responsibility to customize extension and custom endpoint's code to be safe to cache.
:::
