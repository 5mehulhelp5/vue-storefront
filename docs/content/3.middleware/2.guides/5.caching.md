# Caching

Caching is another powerful technique allowing to boost performance of your VSF middleware application and it's reliability. In the following guide, we will cover subject of caching responses from GET endpoints that are possible to cache.

## Implementation

A caching strategy in middleware has to be implemented per integration. We share a very basic extension showing how to approach it for each of our eCommerce integrations (SAP commerce, commercetools, bigcommerce, Adobe commerce). Copy code of an extension for you eCommerce and assign it to constant inside `middleware.config.js`:

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;
        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getCategory") {
          console.log(
            "[CACHING] It's a getCategory request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=31557600");
        } else if (apiMethod === "getFacet") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=315576");
          } else {
            console.log(
              "[CACHING] It's a getFacet request, caching requirements not fulfilled!"
            );
          }
        }
        return response;
      },
    };
  },
};
```

Then add it to the `extensions` array:

```js{20}[middleware.config.js]
const middlewareConfig = {
  integrations: {
    ct: {
      location: "@vsf-enterprise/commercetools-api/server",
      extensions: (extensions) => [...extensions, cachingExtension]
      configuration: {
        // ...
      },
    },
  },
};
```

Since now, if an endpoint is cookie independent then the extension will set Cache-Control response header that should be respected by your CDN and user's browser.

:::warning
Shared caching extension assume you are using the newest version of the middleware's integration and neither extend nor overwrite mentioned endpoints. If you do then you have responsibility to customize extension and custom endpoint's code to be safe to cache or exclude it from caching.
:::

## Understanding the caching extension

In this section, we are going through the code of aforementioned caching extension and explain it's parts.

Firstly, we assign a name to the extension and register `afterCall` hook which is called after execution of endpoint's code but before sending a response to the client. This is the perfect place to make essential checks and set Cache-Control response header. Inside, we have to return an original `response`.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        // ...
        return response
      }
    }
  }
};
```

Secondly, we add a check for HTTP Method. As we want to cache only GET request, we log and finish function's call for other values.
:::tip
We've used console.log and decided to make code of extension super simple and repetitive to make it easy to grasp and be a good starting points for different approaches. Don't hesitate to modify and refactor it to match your vision, and your business' edge cases.
:::

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        return response
      }
    }
  }
};
```

Then we make sure, the response doesn't contain Set-Cookie header. If these things are already check then we can move to checks per endpoint.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        return response
      }
    }
  }
};
```

We create 2 constants containg name of the currently called API endpoint and it's params. There are 3 cases we should consider. In the simplest one, which is for example `getReview` endpoint - there weren't any cookie related operations so we could easily set Cache-Control headers if `apiMethod` equals `getReview`.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        }

        return response
      }
    }
  }
};
```

Way of calling this endpoint via SDK doesn't need any extra steps to be able to cache a response.

```ts
import { sdk } from '~/sdk.config.ts';

const { reviews } = await sdk.commerce.getProductReviews({
  productId: '891c95f8-7bf4-4945-9ab5-00906a5f76ba', // example id
  limit: 20 // example limit
});
```

A case of `getStores` endpoint is a bit more complicated. It used to read `locale` from the cookie. To maintain backward compatibility, we left this mechanism but it won't be used if you pass `locale` via query params. Knowing that, we can only cache responses including `locale` query param in the request's URL.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

To pass `locale` via query params through SDK, call the method like that:

```ts
import { sdk } from '~/sdk.config.ts';

const result = await sdk.commerce.getStores({
  locale: "en"
});
```

A case of `getProduct` endpoint is similiar but a tiny bit more complicated. It used to read a few cookies that are always available and a two that are **optional**. Knowing that, we have to check optional fields the following way `"channel" in params` and send theirs value as `{ channel: null }` in SDK method. Sending value equal `null` for optional fields prevents it from calling fallback mechanism using cookies.

```js [middleware.config.js]
const cachingExtension = {
  name: "caching-extension",
  hooks(req, res) {
    return {
      afterCall({ response }) {
        if (req.method !== "GET") {
          console.log("[CACHING] It's not a GET request, skipping caching");
          return response;
        }

        if (res.getHeader("set-cookie")) {
          console.log(
            "[CACHING] Response containing Set-Cookie header, skipping caching"
          );
          return response;
        }

        const apiMethod = req.params.functionName;
        const params = req.query;

        if (apiMethod === "getReview") {
          console.log(
            "[CACHING] It's a getReview request, caching requirements fulfilled!"
          );
          res.set("Cache-Control", "public, max-age=315576");
        } else if (apiMethod === "getStores") {
          if (params.locale) {
            console.log(
              "[CACHING] It's a getStores request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getStores request, caching requirements not fulfilled!"
            );
          }
        } else if (apiMethod === "getProduct") {
          if (
            params.country &&
            params.currency &&
            params.locale &&
            "channel" in params &&
            "customerGroupId" in params
          ) {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements fulfilled!"
            );
            res.set("Cache-Control", "public, max-age=31557600");
          } else {
            console.log(
              "[CACHING] It's a getProduct request, caching requirements not fulfilled!"
            );
          }
        }

        return response
      }
    }
  }
};
```

To pass required values through SDK (optional and obligatory ones), call the method like that:

```ts
import { sdk } from '~/sdk.config.ts';

const { products } = await sdk.commerce.getProduct({
  country: "PL",
  currency: "USD",
  customerGroupId: null,
  channel: null,
  locale: "en",
});
```

## Why do I need to pass null values?

Object passed to the SDK method will be stringified and set as `body` query param in request URL. Null value will persist. `undefined` would be lost and cause usage of cookies as a fallback.

## What are requirements of the endpoint to cache it safely?

If you created or overwritten an endpoint and would like to cache the response then an endpoint has to be:

- GET HTTP method,
- cookie independent - it cannot build response based on the values of cookie,
- variables has to be send as URL query params.

If aforementioned requirements are fullfiled then you can add another condition for your endpoint in the caching extension and cache the response.

### What if I cache a response not fullfiling requirements?

It is possible that either CDN won't be able to cache or it will cache a response dedicated for particular user and other users will also get this response.

## Can I set multiple response headers?

For example Cache-Control & CDN-Cache-Control? Yes, it's absolutely fine.

## How do we know which SDK method calls which endpoint?

Each SDK method has detailed description and examples of usage. You can check it either in tooltip after hovering on it for a few seconds in your IDE or in API Reference of SDK package in the documentation. There you can find information what is the target URL of certain SDK method.
