# File Upload

The middleware provides built-in support for file uploads using `multer`. This guide explains how to implement and configure file uploads in your middleware application.

::warning
File upload is disabled by default for performance reasons. You need to explicitly enable it in your configuration to use this feature.
::

## Configuration

The file upload service can be configured through the `FileUploadOptions` interface:

```typescript
interface FileUploadOptions {
  enabled?: boolean;
  maxFileSize?: number; // in bytes
  maxFiles?: number;
  allowedMimeTypes?: string[];
  fieldNames?: string[];
}
```

Default configuration:

- Maximum file size: 5MB
- Maximum number of files: 5
- Allowed MIME types: `["image/*", "application/pdf"]`

## Header-Based File Upload Configuration

For performance reasons, file uploads are disabled by default. It is recommended to enable them only when needed and use headers to control file upload behavior. This approach allows for dynamic configuration based on request headers, which is particularly useful for enabling uploads only for specific scenarios, such as authenticated requests or requests with specific headers.

Here's an example of dynamic configuration based on request headers:

```typescript
const app = await createServer(
  { integrations: config.integrations },
  {
    fileUpload: (req) => ({
      enabled: req.headers["x-enable-upload"] === "true",
      maxFileSize: req.headers["x-upload-size"]
        ? parseInt(req.headers["x-upload-size"])
        : 5242880, // Default to 5MB
      maxFiles: 5,
      allowedMimeTypes: ["image/*", "application/pdf"],
      fieldNames: [],
    }),
  }
);
```

In this example:

- File uploads are only enabled when the `x-enable-upload: true` header is present.
- The maximum file size can be controlled via the `x-upload-size` header.
- Other options remain static but could also be made dynamic based on your needs.

This method is preferred as it provides flexibility and control over file upload behavior, ensuring that uploads are only enabled when necessary and under specific conditions.

## Implementation Example

Here's how to implement a file upload endpoint that connects with the SDK example:

```typescript
// api/custom-methods/uploadFile.ts
export async function uploadFile(
  context: IntegrationContext
): Promise<CustomMethodResponse> {
  const files = context.req.files;
  if (!files) {
    throw new Error("No files were uploaded");
  }

  const client = await context.getApiClient("commerce");
  const formData = new FormData();

  // Handle both multiple files and single file uploads
  if (Array.isArray(files)) {
    files.forEach((file) => {
      formData.append("files", new Blob([file.buffer]), file.originalname);
    });
  }

  // Send files to your external service endpoint
  const response = await client.api.post(
    "/your-external-service/upload",
    formData,
    {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    }
  );

  return response.data;
}
```

## Usage with SDK

::alert{type="success"}
For detailed instructions on using file upload with the SDK, visit the [File Upload SDK Guide](https://docs.alokai.com/sdk/advanced/file-upload).
::

## Custom Configuration

You can customize the file upload behavior by modifying the middleware options:

```typescript
// apps/storefront-middleware/src/index.ts
const app = await createServer(config, {
  // Custom file upload configuration
  fileUpload: {
    enabled: true,
    maxFileSize: 10 * 1024 * 1024, // 10MB
    maxFiles: 10,
    allowedMimeTypes: ["image/*", "application/pdf", "text/plain"],
    fieldNames: ["avatar", "documents"], // Specific field names to accept
  },
  // ...
});
```

## Additional Parameters

When uploading files, you can include additional parameters alongside your files. These parameters can be accessed in your middleware implementation:

```typescript
// api/custom-methods/uploadFile.ts
export async function uploadFile(
  context: IntegrationContext,
  additionalParams: Record<string, unknown>
): Promise<CustomMethodResponse> {
  const files = context.req.files;

  if (!files) {
    throw new Error("No files were uploaded");
  }

  const client = await context.getApiClient("commerce");
  const formData = new FormData();

  // Add additional parameters to formData
  Object.entries(additionalParams).forEach(([key, value]) => {
    formData.append(key, value);
  });

  // Handle files
  if (Array.isArray(files)) {
    files.forEach((file) => {
      formData.append("files", new Blob([file.buffer]), file.originalname);
    });
  }

  // Send files and additional parameters to your external service
  const response = await client.api.post(
    "/your-external-service/upload",
    formData,
    {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    }
  );

  return response.data;
}
```

## Security Considerations

1. **File Size**: Always set appropriate file size limits to prevent server overload
2. **File Types**: Restrict allowed MIME types to prevent security vulnerabilities
3. **File Count**: Limit the number of files that can be uploaded simultaneously
4. **Validation**: The middleware performs automatic validation based on your configuration

::warning
The maximum file size is capped at 10MB regardless of configuration for security purposes.
::
